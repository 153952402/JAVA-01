
1. SerialGC
	SerialGC 是单线程垃圾回收器，收集时用户线程必须暂停，新生代使用标记复制算法，
	老年代采用标记整理算法，适用于单核处理器或处理器核心数较少的环境，由于没有线程
	交互的开销，且实现简单，因此是单线程收集效率最高的收集器，所以它依然是HotSpot虚拟机
	运行在客户端模式下的默认垃圾收集器。另外，在作业1的512MB测试环境中得到生成对象次数如下
		UseSerialGC  		10s: 98996次  60s: 580312次
		UseParallelGC		10s: 42935次  60s: 224650次
		UseConcMarkSweepGC	10s: 67487次  60s: 432908次
		UseG1GC				10s: 90980次  60s: OOM

	上面数据表明SerialGC在512MB内存较小的环境其吞吐量相比ParallelGC、CMSGC, Serial是最高的，
	与G1相比吞吐量还略高，另外在G1在60s压测中却偶尔会OOM,我猜测是G1的内存利用率不高导致的。
	

2. ParallelGC
	ParallelGC 是多线程垃圾回收器，新生代采用标记复制算法，老年代采用标记整理算法，相当于ParNew的升级版，
	其垃圾收集目标是尽可能提供高且可控的吞吐量，提供了-XX:MaxGCPauseMillis, -XX:GCTimeRatio两个参数，
	供用户调控垃圾回收吞吐量，换来的是单次收集时间可能会很长，
	在作业1的4096MB测试环境中得到生成对象次数数据如下：
		UseSerialGC  		10s: 301088次  60s: 1946518次
		UseParallelGC		10s: 321731次  60s: 1950130次
		UseConcMarkSweepGC	10s: 229333次  60s: 1521984次
		UseG1GC				10s: 324036次  60s: 2119377次

	上面数据表明ParallelGC的吞吐量在60s压测时间条件下，其吞吐量大幅超过ConcMarkSweepGC, 但UseSerialGC却与其相当
	真的是诧异，但G1不论是在压测时间10s条件下，还是60s条件下都有略超过ParallelGC的势头，如果继续提高机器的核心数，
	可能ParallelGC才能发挥更大的优势。

3. UseConcMarkSweepGC
	CMS GC是一款主打“并发低停顿收集器”，通常与Serial搭配使用收集新生代，其采用多个线程、标记清除算法进行垃圾回收，
	可与用户线程共同运行，减少STW时间，如果希望有良好的交互体验，CMS收集器就非常符合这类应用的需求，
	在上面分析SerialGC、ParallelGC时可以看到CMS在吞吐上表现平平，虽然没有很惊艳，但是通常情况下也没有垫底，
	但是优势是可以与用户线程并发，减少STW。根据适合的场景来看，总体来说还是不错的。

4. UseG1GC
	G1 是一款早在JDK7中便存在的收集器，但是在JDK9中才被正式宣布取代Parallel Scavenge加Parallel Old组合，成为
	服务器端模式下的默认垃圾收集器，G1中使用了很多开创性的思想，例如基于Region的堆内存布局、停顿预测模型、具有优先级的区域回收方式等
	在在作业1的测试中发现，其让人感觉真的是一款全能型的垃圾回收器，不论是在小内存，还是大内存，不论是1s压测时间，或者是60s的压测时间
	其都能在吞吐上与其他垃圾收集器保持持平，甚至超越，最恐怖的是，在如此吞吐下，依然还可以拥有与其他用户线程并发的能力。
	