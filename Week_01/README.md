疑问：  

    问题一. 
        问题描述：
            利用classLoader可以实现.class的加密防止反编译，但是如果.class加密了，
            那其打的jar包丢到lib目录下后如何保证IDE在开发时还能准确import被加密的类以及
            识别其中的方法。

        问题思考：
            我简单搜索了下网上的信息，不知是我键入关键字有不准确还是讨论这个
            问题的人比较少，我没有找到比较有价值的信息，但是按照我的理解，IDE能实现自动提示
            应该靠的就是类似javap的功能，去解析未被加密处理的.class文件，以获取方法表和字段表
            再配合常量迟给出字段和方法提示才对。

        可能方案：
            我思考了下如何实现加密.class文件，同时又能够让IDE进行完成提示。
            
            方案一：
                从加密的目的来看，我们想要加密是为了防止别人去了解我们的实现逻辑，
                而实现逻辑大多是放在【方法】内，而方法经过编译器处理会变成方法表，
                方法中的逻辑代码会变成方法表的code属性，我们只要对code属性中的字
                节码加加密即可，而不需要加密整个.class文件，在classloader中对应解密
                即可，这样保证了最重要的方法信息无法获取，其他信息也没有什么价值。
        
            方案二：
                在方案一的角度来看，是利用了.class编译的逻辑和结果，采取部分加密的    
                方式，那如果确实想进行完全加密呢？从jar包使用者的角度来看，要想实现
                IDE方法提示等，只要保证对外暴露的那些方法所在的类没有加密即可，也就是
                我们可以加入一个中间层，我们提供两个文件给使用者
                    1. A.xlass
                    2. Aproxy.class
                其中A.xlass是完全加密的，而 Aproxy.class是正常class文件，
                Aproxy.class是依赖A.class，只是对A.xlass做简单封装，Aproxy.class
                的生成可以通过未加密的A.class进行正常编译得到，然后再对A.class进行加密
                得到A.xlass，最后加上特制的classloader将两个文件一起对外提供应该就可以了。

  

    问题二：
        问题描述：通过各种书籍和资料了解java中的classloader和溯源委派模型，
        并被灌输了classloader和溯源委派模型带来的好处，
            如: 
                1.可以隔离类，解决多版本类加载冲突，如tomcat WebAppClassLoader
                2.可以实现从网络中加载.class，如applet
                3.可以实现.class加密
                2.使类有了层次关系，解决基础类加载不一致和安全问题
        正如上述描述的，我用了“灌输”一词，我尝试着将理解交给时间，但到目前为止，
        我没有哪天能提壶灌顶般的大彻大悟的去自然理解其中的因果关系，我想老师和助教们
        能帮助我去对比一下其他语言是如何解决和实现上诉的一些列问题，因为我本人深度
        掌握的语言并不多，无法进行有效详细对比进行理解。

        这个问题我感觉我可能说的有点乱，我简单明确细化下问题：
            1. java中的classloader和溯源委派模型概念，其他语言有吗？
                例如c#，javasrcipt, 如果没有，那他们是如何解决类加载一致等问题？
               另外我找到了一篇知乎文章，但回答半知半解：
                https://www.zhihu.com/question/30366119
            2. 假设我想完全抛弃java的复杂的classloder概念和溯源委派模型，
                有没有简单、易于理解的替代方案去保证现有的java大厦不出问题？
            